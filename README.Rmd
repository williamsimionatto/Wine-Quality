---
title: "Red Wine Quality"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
library(ggplot2)
```

Este projeto tem por objetivo treinar um modelo do machine learning para prever a qualidade do vinho vermelho. Para este treinamento será utilizado o modelo `Árvore de decisão`, por meio do pacote (`C50`).

## Dataset

```{r echo=FALSE}
WineData <- read.table("winequality-red.csv", sep=",", header=TRUE)
WineData$quality <- as.factor(WineData$quality)
```

O Dataset está disponível em: [Red Wine Quality](https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009).

O Dataset apresenta os dados de `r nrow(WineData)` vinhos, distribuídos entre `r ncol(WineData)` variáveis coletadas com base em testes físicos-químicos:

1.  `fixed acidity`

  * Representa a volatilidade dos ácidos presentes no vinho, ou seja, ácidos que não evaporam facilmente.

2.  `volatile acidity`

  * Representa a quantidade de ácido acético no vinho, ou seja, níveis muito altos podem causar um sabador de vinagre no vinho.

3.  `citric acid`

  * Representa a quantidade de ácido cítrico presente no vinho.

4.  `residual sugar`

  * Representa a quantidade de açúcar restante no vinho após o processo de fermentação.

5. `chlorides`

  * Representa a quantidade de sal presente no vinho.

6.  `free sulfur dioxide`

  * Representa a quantidade de gás SO2 liberado.

7.  `total sulfur dioxide`

  * Representa o total de gás SO2.

8. `density`

  * Representa a densidade do vinho.

9.  `pH`

  * Representa quão ácido ou básico é um vinho em uma escala de 0 (muito ácido) a 14 (muito básico);

10. `sulphates`

  * Um aditivo de vinho que pode contribuir para os níveis de dióxido de enxofre

11. `alcohol`

  * Representa a percentagem de teor alcoólico do vinho.

12 . `quality`

  * Representa a pontuação do vinho, em uma escala de 0 a 10. Sendo 0 um vinho considerado `ruim` e 10 um vinho `bom`.


## Análise Exploratória dos dados

Uma breve análise dos dados, para poder entender suas características. 

```{r echo=FALSE}
ggplot(WineData, aes(x = density, y = alcohol, color = quality)) +
  geom_point(alpha=0.1) +
  geom_smooth(se = FALSE, size=0.8) +
  ggtitle('Densidade por teor alcoolico do vinho') +
  labs(y = 'Teor Alcoolico', x = 'Densidade', color = 'Qualidade do Vinho')
```

A partir do gráfico gerado, podemos observar que a tendência geral é que quanto maior o teor álcoolico do vinho, menor a sua densidade. Nesta análise, pode-se concluir também que quanto maior a qualidade do vinho, maior o teor alcoólico e menor a densidade.

```{r echo=FALSE}
ggplot(WineData, aes(x = residual.sugar, color = quality)) +
  geom_density() +
  scale_color_brewer(type = 'seq', palette = 'RdPu') +
  scale_x_log10(breaks = seq(1, 15, 2)) +
  scale_y_continuous(breaks = seq(0, 1.5, .25)) +
  labs(x = 'Açúcar Residual por Litro', y = 'Densidade', color = 'Qualidade do Vinho') +
  ggtitle('Densidade por açúcar residual em escala log segmentado por qualidade')

```

Vemos que a densidade por açúcar residual tem uma distribuição bimodal para os vinhos de maior qualidade e uma cauda longa para os de menor qualidade mas de forma pouco significativa.


```{r echo=FALSE}
ggplot(WineData, aes(x = pH)) +
  geom_histogram(binwidth = .1, fill = 'chartreuse',  col=I("chartreuse4")) +
  ggtitle("Distribuição pH") +
  xlab("pH") +
  ylab("Count")
```

O pH presentes nos vinhos, apresenta uma distribuição normal e bem concentrada, na faixa entre `3.0` e `3.7`.

## Preparação dos dados para aplicação do modelo
Para preparação dos dados, foi necessário criar uma variável categorica para a qualidade do vinho, aplicando o seguinte critério:

```{r echo=FALSE}
WineData <- read.table("winequality-red.csv", sep=",", header=TRUE)
WineData$quality <- ifelse(WineData$quality < 5, 'ruim', ifelse(WineData$quality > 6, 'bom', 'normal'))
WineData$quality <- as.factor(WineData$quality)
```

> Qualidade < 5 = ruim,
> Qualidade > 5 & Qualidade < 6 = normal,
> Qualidade > 6 = boa

Os dados foram separados aleatoriamente entre dados de 'test' e 'training', onde 80% dos dados foram separados para testes e os 20% restantes separados para treinamento do modelo.

```{r echo=FALSE}

set.seed(123)
train_sample <- sample(nrow(WineData), 0.8 * nrow(WineData))
WineData_train <- WineData[train_sample, ]
WineData_test <- WineData[-train_sample, ]

training_distributiation =  prop.table(table(WineData_train$quality))
test_distributiation = prop.table(table(WineData_test$quality))
```

Após a separação os dados ficaram distruibuidos da seguinte forma:
```{r echo=FALSE}
  knitr::kable(training_distributiation, caption = "Distribuição dos dados de treinamento")
  
  knitr::kable(test_distributiation, caption = "Distribuição dos dados de testes")
```

É possível notar que os dados não estão distribuídos de maneira uniforme, pois em ambos os datasets há uma maior concentração de vinhos considerados `normais`, cerca de 80%.

